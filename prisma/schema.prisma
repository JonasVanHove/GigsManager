generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Gig {
  id String @id @default(cuid())

  // ── Event details ──────────────────────────────────────
  eventName       String
  date            DateTime
  performers      String // band name or comma-separated member names
  numberOfMusicians Int
  performanceLineup String? // optional names for this performance
  managerPerforms Boolean @default(true) // whether the user performs in this gig
  
  // ── Band members for this gig ──────────────────────────
  bandMembers     GigBandMember[]

  // ── Optional setlist ───────────────────────────────────
  setlistId String?
  setlist   Setlist? @relation(fields: [setlistId], references: [id], onDelete: SetNull)

  // ── Financials ─────────────────────────────────────────
  isCharity         Boolean @default(false) // whether this is a charity/pro bono performance
  performanceFee    Float           // music fee — split among musicians
  technicalFee      Float  @default(0) // optional — belongs to manager, not split
  managerBonusType  String @default("fixed") // "fixed" | "percentage"
  managerBonusAmount Float @default(0) // bonus value ($ or %)

  // ── Performance fee distribution ───────────────────────
  performanceDistribution String @default("equal") // "equal" | "managerFixed" | "custom"
  managerPerformanceAmount Float? // if managerFixed: amount manager claims from performance fee

  // ── Fee claims — whether manager claims these fees for this gig ──
  claimPerformanceFee Boolean @default(true)
  claimTechnicalFee   Boolean @default(true)
  technicalFeeClaimAmount Float? // amount of technical fee to claim (null = claim all)

  // ── Payment handling ───────────────────────────────────
  managerHandlesDistribution Boolean @default(true) // whether manager handles payment split to band members

  // ── Payment tracking ───────────────────────────────────
  paymentReceived     Boolean   @default(false)
  paymentReceivedDate DateTime?
  bandPaid            Boolean   @default(false)
  bandPaidDate        DateTime?

  // ── Advance payments ────────────────────────────────────
  advanceReceivedByManager Float @default(0) // Advance amount you received from client
  advanceToMusicians Float @default(0)        // Advance amount you paid to musicians

  // ── Meta ───────────────────────────────────────────────
  bookingDate DateTime @default(now()) // when the booking was made (default: now, but editable)
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ── User ownership — every gig belongs to one user ─────
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([date])
  @@index([paymentReceived])
  @@index([bandPaid])
  @@index([userId, date]) // composite index for common query: user's gigs sorted by date
  @@index([userId, paymentReceived]) // for pending payments queries
  @@index([setlistId])
}

// ── Setlists ─────────────────────────────────────────────
model Setlist {
  id String @id @default(cuid())

  title       String
  description String?

  // Owner
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Linked gigs (optional)
  gigs Gig[]

  // Items
  items SetlistItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
}

model SetlistItem {
  id String @id @default(cuid())

  setlistId String
  setlist   Setlist @relation(fields: [setlistId], references: [id], onDelete: Cascade)

  order Int
  type  String // "song" | "note"

  title  String?
  notes  String?
  chords String?
  tuning String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([setlistId, order])
}

model User {
  id String @id @default(cuid())

  // Supabase Auth UID (from auth.users table)
  supabaseId String @unique

  email String @unique
  name  String?

  // All gigs belonging to this user
  gigs        Gig[]
  settings    UserSettings?
  investments Investment[]
  bandMembers BandMember[]
  setlists    Setlist[]

  // Notifications and webhooks
  notifications       Notification[] @relation("UserNotifications")
  notificationPref    NotificationPreference? @relation("UserNotificationPreference")
  webhooks            Webhook[] @relation("UserWebhooks")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserSettings {
  id String @id @default(cuid())

  // Which currency to display amounts in (ISO 4217 code)
  currency String @default("EUR")

  // Whether the user (manager) claims these fee components
  claimPerformanceFee Boolean @default(true)
  claimTechnicalFee   Boolean @default(true)

  // Theme preference: "light" | "dark" | "system"
  theme String @default("system")

  // Owner
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Investment {
  id String @id @default(cuid())

  // Investment details
  amount      Float
  description String?
  date        DateTime @default(now())

  // Owner
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([date])
}

// ── Band Members & Relationships ─────────────────────────────────
model BandMember {
  id String @id @default(cuid())

  // Member details
  name  String
  email String?
  phone String?
  notes String?
  bands String[] @default([])

  // Owner (the user who manages this band member)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Gigs this member participated in
  gigs GigBandMember[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, name]) // unique member name per user
  @@index([userId])
}

// ── Junction table: which band members performed in which gigs ────
model GigBandMember {
  id String @id @default(cuid())

  // The gig and band member
  gigId String
  gig   Gig    @relation(fields: [gigId], references: [id], onDelete: Cascade)

  bandMemberId String
  bandMember   BandMember @relation(fields: [bandMemberId], references: [id], onDelete: Cascade)

  // How much did this member earn for this gig?
  earnedAmount Float @default(0)
  paidAmount   Float @default(0)  // how much has been paid to them already
  
  // Custom performance fee for this specific member (null = use equal split)
  customPerformanceAmount Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([gigId, bandMemberId])
  @@index([gigId])
  @@index([bandMemberId])
  @@index([gigId, bandMemberId]) // composite for quick lookups
}

// ── Notifications ──────────────────────────────────────────────────
model Notification {
  id String @id @default(cuid())

  // User who receives this notification
  userId String
  user   User   @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  // Notification content
  type          String   // payment_received, payment_overdue, upcoming_gig, band_paid, custom
  title         String
  message       String
  icon          String?
  actionUrl     String?
  actionLabel   String?

  // Status tracking
  status        String   @default("unread") // unread, read, dismissed
  createdAt     DateTime @default(now())
  readAt        DateTime?
  dismissedAt   DateTime?

  @@index([userId, status])
  @@index([userId, createdAt])
}

// ── Notification Preferences ──────────────────────────────────────
model NotificationPreference {
  id String @id @default(cuid())

  // User who owns these preferences
  userId String @unique
  user   User   @relation("UserNotificationPreference", fields: [userId], references: [id], onDelete: Cascade)

  // Notification channels
  emailNotifications    Boolean @default(true)
  inAppNotifications    Boolean @default(true)

  // Event types to notify about
  paymentReminders      Boolean @default(true)
  overdueAlerts         Boolean @default(true)
  upcomingGigReminders  Boolean @default(true)
  dailyDigest           Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ── Webhooks ───────────────────────────────────────────────────────
model Webhook {
  id String @id @default(cuid())

  // User who owns this webhook
  userId String
  user   User   @relation("UserWebhooks", fields: [userId], references: [id], onDelete: Cascade)

  // Webhook configuration
  provider String   // discord, n8n, custom
  url      String
  events   String[] // payment_received, payment_overdue, band_paid, upcoming_gig, gig_completed
  enabled  Boolean  @default(true)
  name     String?
  secret   String?

  // Activity tracking
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastTriggeredAt DateTime?

  // Webhook logs
  logs WebhookLog[]

  @@index([userId, enabled])
  @@index([userId, createdAt])
}

// ── Webhook Delivery Logs ──────────────────────────────────────────
model WebhookLog {
  id String @id @default(cuid())

  // Associated webhook
  webhookId String
  webhook   Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  // Event that triggered the webhook
  event  String // payment_received, payment_overdue, etc.
  data   String // JSON stringified data

  // Delivery result
  statusCode Int?    // HTTP status code
  response   String?
  error      String?
  success    Boolean @default(false)

  createdAt DateTime @default(now())

  @@index([webhookId, createdAt])
  @@index([success])
}

// ── Update User model to include new relations ────────────────────
// Note: User model above needs to be updated with these relations:
// notifications    Notification[] @relation("UserNotifications")
// notificationPref NotificationPreference? @relation("UserNotificationPreference")
// webhooks         Webhook[] @relation("UserWebhooks")